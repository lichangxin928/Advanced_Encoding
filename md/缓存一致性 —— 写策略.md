因为cache的内容是部分主存内容的副本，应该与主存内容保持一致。而CPU对cache的写入更改了cache内容，如何与主存内容保持一致就有几种写操作工作方式可供选择，统称为**写策略**。

　   **1．写回法（write--back）**
　　当CPU对cache写命中时，只修改cache的内容不立即写入主存，只当此行被换出时才写回主存。这种策略使cache在CPU－主存之间，不仅在读方向而且在写方向上都起到高速缓存作用。对一cache行的多次写命中都在cache中快速完成修改， 只是需被替换时才写回速度较慢的主存，减少了访问主存的次数从而提高了效率。为支持这种策略，每个cache行必须配置一个修改位，以反映此行是否被CPU修改过。当某行被换出时，根据此行修改位为1还是为0，决定是将该行内容写回主存还是简单地弃之 而不顾。 
　　对于cache写未命中，写回法的处理是为包含欲写字的主存块在cache分配一行，将此块整个拷贝到Cache后对其进行修改， 因为尔后对此块的多次读/写访问的可能性很大。拷贝主存块时虽已读访问到主存，但此时并不对主存块修改。因为换出的cache很可能此期间要写回主存，为避免此过程耗时太长，写未命中对将新块读入后，只在cache中进行写修改。统一地将主存写修改操作留待换出时进行。 
　　这种写cache与写主存分开进行方式可显著减少写主存次数，但写回法也带来了cache / 主存严重的不一致性。后面将要介绍的MESI协议，就是一个针对写回法的维护cache一致性的协议。 
　　**2．写直达法（write--through）** 
　　又称全写法，写透。是当cache写命中时，cache与主存同时发生写修改。这种策略 显然较好地维护了cache与主存的内容一致性，但这并不等于说全部解决了一致性问题。例如在多处理器系统中各CPU都有自己的cache，一个主存块若在多个cache中都有一份拷贝的话，某个CPU以写直达法来修改它的cache和主存时，其它cache中的原拷贝就过时了。即使在单处理器系统中，也有I／O设备不经过cache向主存写入的情况。总之，仍要关注一致性问题。 
　　当cache写未命中时，只有直接向主存写入了，但此时是否将修改过的主存块取到cache，写直达法却有两种选择。一种是取来并且为它分配一个行位置，称为WTWA法（Write--Through--with--Write--Allocate）。另一种是不取称为WTNWA法（WriteThrough--with．NO-Write--Allocate）。前 一种方法保持了cache / 主存的一致性，但操作复杂，而后一种方法操作简化，但命中率降低，内存的修改块只有在读未命中对cache 进行替换时，才有可能映射到cache 。 
　　写直达法是写cache与写主存同步进行，其优点是cache每行无需设置一个修改位以及相应的判测逻辑。写直达法的缺点是，cache对CPU向主存的写操作无高速缓冲功能，降低了cache的功效。 
　　**3．写一次法（write--once）**
　　写一次法是一种基于写回法又结合了写直达法的写策略，即写命中和写未命中的处理与写回法基本相 同，只是第一次写命中时要同时写入主存。这种策略主要用于某些处理器的片内cache，例如Pentium处理器的片内数据cache就采用的是写一次 法。因为片内cache写命中时，写操作就在CPU内部高速完成，若没有 内存地址及其它指示信号送出，就不便于系统中的其它cache监听（snoop）。采用写一次法，在第一次片内cache写命中时， CPU要在总线上启动一个存储写周期。其它cache监听到此主存块地址及写信号后，即可把它们各自保存可能有的该块拷贝及时作废（无效处理）。尔后若有 对片内cache此行的再次或多次写命中，则按回写法处理，无需再送出信号了。这样虽然第一次写命中时花费了一个存 储周期，但对维护系统全部cache的一致性有利。而大多的cache写操作不涉及到片 外，对指令流水执行有利

 